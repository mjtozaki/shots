<!DOCTYPE html>
<html>
<head>
  <style>
    // https://stackoverflow.com/a/24894523
    // LESS Mixin for ratio dimensions    
/*     .viewportRatio(@x, @y) {
      width: 100vw;
      height: @y * 100vw / @x;
      max-width: @x / @y * 100vh;
      max-height: 100vh;
    } */

    .shot_plot {
      // Force a ratio of 5:1 for all <div>
/*       .viewportRatio(4, 3); */
      width: 100vw; 
      height: 75vw; /* height:width ratio = 3/4 = .75  */
      max-height: 100vh;
      max-width: 133.33vh; /* 4/3 = 1.3333 */



      margin: 0;
/*       position: absolute;
      top: 0; right: 0; bottom: 0; left: 0; */
    }
    
    .shot_text {
      // Force a ratio of 5:1 for all <div>
/*       .viewportRatio(4, 3); */

      margin: 0;
/*       position: absolute;
      top: 0; right: 0; bottom: 0; left: 0; */
    }
  </style>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/js-url/2.5.3/url.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <script type="text/javascript">
    "use strict";
    var GoogleAuth;
    var SCOPE = 'https://www.googleapis.com/auth/drive.readonly';
//       SCOPE += ' https://www.googleapis.com/auth/drive.appdata';
    
    function gapi_loaded() {
      console.log('Loading gapi');
      gapi.load('client:auth2', initClient);
    }
    
    /* Based upon:
     *  -http://ryanogles.by/an-exploration-of-javascript-builders/
     *  -https://medium.com/@axelhadfeg/builder-pattern-using-javascript-and-es6-ec1539182e24
     */
    class BaseBuilder {
      init() {  
        Object.keys(this).forEach((key) => {
          const setterName = `set${key.substring(0,1).toUpperCase()}${key.substring(1)}`;
          this[setterName] = (value) => {
            this[key] = value;
            return this;
          };
        });
      }

      build() {
        const fields = Object.keys(this).filter((key) => (
          typeof this[key] !== 'function'
        ));
                
        var properties =  fields.reduce((returnValue, key) => {
          return {
            ...returnValue,
            [key]: {
              value: this[key],
              writable: false
            }
          };
        }, {});
        
        var outputObject = {};
        Object.defineProperties(outputObject, properties);
        
        this.addMemberFunctions(outputObject);
        
        return outputObject;
        
//         return keysNoWithers.reduce((returnValue, key) => {
//           return {
//             ...returnValue,
//             [key]: this[key]
//           };
//         }, {});
      }
    }

    class ShotSyntaxError extends Error {
      constructor(...params) {
        super(...params);
        
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ShotSyntaxError);
        }
      }
    }
    class ShotBuilder extends BaseBuilder {
      constructor() {
        super();
        
        this.timestamp = new Date(0);
        this.elapsed = [];
        this.pressure = [];
        this.flow = [];
        this.weight = [];
        this.flowWeight = [];
        this.temperatureBasket = [];
        this.temperatureMix = [];
        this.temperatureTarget = [];
        this.author = "";

        super.init();
      }
      addMemberFunctions(obj) {
        obj.renderText = function(div) {
          var BR = "<br>";
          var html = 
            "timestamp: " + this.timestamp.toString() + BR
            + "elapsed: " + this.elapsed + BR
            + "pressure: " + this.pressure + BR
            + "flow: " + this.flow + BR
            + "weight: " + this.weight + BR
            + "flowWeight: " + this.flowWeight + BR
            + "temperatureBasket: " + this.temperatureBasket + BR
            + "temperatureMix: " + this.temperatureMix + BR
            + "temperatureTarget" + this.temperatureTarget + BR
            + "author: " + this.author + BR;
          div.html(html);
        }
        // Move this stuff to polymorphic renderers.
        
        obj.renderPlot = function(plot) {
//           var plot = document.getElementById('shot_plot');
          var pressure = {
            x: this.elapsed,
            y: this.pressure,
            mode: 'lines',
            name: 'Pressure',
            line: {
              color: 'green'
            }
          };
          var flow = {
            x: this.elapsed,
            y: this.flow,
            mode: 'lines',
            name: 'Flow',
            line: {
              color: 'blue'
            },
            yaxis: 'y2'
          };
          var temperatureBasket = {
            x: this.elapsed,
            y: this.temperatureBasket,
            mode: 'lines',
            name: 'Basket Temperature',
            line: {
              color: 'red'
            },
            yaxis: 'y3'
          };
          
          // TODO: align domain such that temperature target is centered.
          var center =
              this.temperatureTarget.reduce(
                (accumulator, currentValue) => accumulator + currentValue)
              / this.temperatureTarget.length;
          var maxDifference = [...Array(this.elapsed.length).keys()]
              .map(
                (index) => Math.max(Math.abs(this.temperatureTarget[index] - center), Math.abs(this.temperatureBasket[index] - center)))
              .reduce((accumulator, currentValue) => Math.max(accumulator, currentValue), 0);
          var temperatureRange = [center - maxDifference, center + maxDifference];
          var temperatureTarget = {
            x: this.elapsed,
            y: this.temperatureTarget,
            mode: 'lines',
            name: 'Target Basket Temperature',
            line: {
              color: 'red',
              dash: 'dash'
            },
            yaxis: 'y3'
          };
            
          var data = [pressure, flow, temperatureBasket, temperatureTarget];
          var layout = {
            title: `Shot @ ${this.timestamp}`,
//             showlegend: false,
            xaxis: {
              title: 'Elapsed (s)',
              domain: [0, 0.9],
            },
            yaxis: {
              title: 'Pressure (bar)',
              titlefont: {color: 'green'},
              tickfont: {color: 'green'},
              side: 'left'
            },
            yaxis2: {
              title: 'Flow (mL/s)',
              titlefont: {color: 'blue'},
              tickfont: {color: 'blue'},
              anchor: 'x',
              overlaying: 'y',
              side: 'right'
            },
            yaxis3: {
              title: 'Basket Temperature (C)',
              titlefont: {color: 'red'},
              tickfont: {color: 'red'},
              anchor: 'free',
              overlaying: 'y',
              side: 'right',
              position: 1,
              autorange: false,
              range: temperatureRange
            },
          };
          Plotly.plot(plot, data, layout);
//           Plotly.plot(plot, [{
//           x: [1, 2, 3, 4, 5],
//           y: [1, 2, 4, 8, 16] }], {
//           margin: { t: 0 } } );
        }
      }
    }
    function tclListToNumberArray(tclList) {
      return tclList.split(/\s+/).map(numStr => Number(numStr));
    }
    function shotFromShotFileContents(contents) {
      var S_TO_MS = 1000;
      var attrs = tclArrayDeserializer(contents);
      if (!attrs.has('settings')) {
        throw new ShotSyntaxError("settings key not present.");
      }
      var settings = tclArrayDeserializer(attrs.get('settings'));
      if (!attrs.has('machine')) {
        throw new ShotSyntaxError("machine key not present.");
      }
      var machine = tclArrayDeserializer(attrs.get('machine'));
      
      var espressoElapsed = tclListToNumberArray(attrs.get('espresso_elapsed'));
      var espressoPressure = tclListToNumberArray(attrs.get('espresso_pressure'));
      var espressoWeight = tclListToNumberArray(attrs.get('espresso_weight'));
      var espressoFlow = tclListToNumberArray(attrs.get('espresso_flow'));
      var espressoFlowWeight = tclListToNumberArray(attrs.get('espresso_flow_weight'));
      var espressoTemperatureBasket = tclListToNumberArray(attrs.get('espresso_temperature_basket'));
      var espressoTemperatureMix = tclListToNumberArray(attrs.get('espresso_temperature_mix'));
      
      console.log("espresso_elapsed: " + attrs.get('espresso_elapsed'));
      console.log("espressoElapsed: " + espressoElapsed);
      var numPoints = espressoElapsed.length;
      if (![espressoPressure, espressoWeight, espressoFlow, espressoFlowWeight, espressoTemperatureBasket, espressoTemperatureMix]
          .every(sequence => sequence.length == numPoints)) {
        throw ShotSyntaxError("Number of data points do not match across all dimensions.");
      }

      var builder = new ShotBuilder();
      return builder
        .setTimestamp(
          new Date(Number(attrs.get('clock') * S_TO_MS)))
        .setElapsed(espressoElapsed)
        .setPressure(espressoPressure)
        .setWeight(espressoWeight)
        .setFlow(espressoFlow)
        .setFlowWeight(espressoFlowWeight)
        .setTemperatureBasket(espressoTemperatureBasket)
        .setTemperatureMix(espressoTemperatureMix)
        .setTemperatureTarget(Array(numPoints).fill(Number(settings.get('espresso_temperature'))))
        .setAuthor(settings.get('author'))
        .build();
    }

    
    class TclError extends Error {
      constructor(...params) {
        super(...params);
        
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, TclError);
        }
      }
    }
    var TOKEN_TYPE_EOF = 1;
    var TOKEN_TYPE_WORD = 2;
    class Token {
      constructor(tokenType, value) {
        this.tokenType = tokenType;
        this.value = value;
      }
    }
    /** 
     * Processes similar to the following Tcl, where retName is a variable
     * representing the returned value of the function:
     *
     *   upvar 1 $retName arrRef
     *   array set arrRef $arrayString
     *
     * Respects rules 3 and 6 of Tcl. See https://www.tcl.tk/man/tcl/TclCmd/Tcl.htm.
     */
    function tclArrayDeserializer(arrayString) {
      // Looks for zero or more pairs of words, where a word is either
      // 1. a sequence of 1 or more non-whitespace characters, or
      // 2. a sequence of characters within a left brace '{' and its matched right brace '}', respecting nested braces.
      // A pair of words is separated by at least one non-newline whitespace characters,
      // and pairs are separated by at least one newline.
      // TODO: implement newline-related restrictions.
      
      // tokens:  (\s+), (\n), ([a-zA-Z0-9_]+), ({), (})
      var tokenizer = new Tokenizer(arrayString);
      var tclArray = new Map();
      while (1) {
        var token = tokenizer.nextToken();
        if (token.tokenType == TOKEN_TYPE_EOF) {
          break;
        }
        var key = token.value;
        token = tokenizer.nextToken();
        if (token.tokenType == TOKEN_TYPE_EOF) {
          throw new TclError("Serialized Tcl arrays should have an even number of elements.");
        }
        tclArray.set(key, token.value);
      }
      return tclArray;
    }
    class Tokenizer {
      constructor(str) {
        this.str = str;
        this.pos = 0;
      }
      static isWhitespace(ch) {
        return /\s/.test(ch);
      }
      static isWordChar(ch) {
        return /[a-zA-Z0-9_#:\.+-]/.test(ch);
      }
      eatWhitespace() {
        while (this.pos < this.str.length && Tokenizer.isWhitespace(this.str.charAt(this.pos))) {
          ++this.pos;
        }
      }
      extractWord() {
        var origin = this.pos;
         while (this.pos < this.str.length && Tokenizer.isWordChar(this.str.charAt(this.pos))) {
           ++this.pos;
         }
        return this.str.substring(origin, this.pos);
      }
      extractBracedWord() {
        var origin = this.pos;
        var depth = 0;
        do {
          var ch = this.str.charAt(this.pos);
          if (ch === '{') {
            ++depth;
          } else if (ch === '}') {
            --depth;
          }
          ++this.pos;
        } while (this.pos < this.str.length && depth != 0);
        if (depth != 0) {
          throw new TclError("Unmatched curly braces.");
        }
        return this.str.substring(
          origin+1, // Skip the '{'.
          this.pos-2); // End before the '}'.
      }
      nextToken() {
        this.eatWhitespace();
        
        if (this.pos >= this.str.length) {
          return new Token(TOKEN_TYPE_EOF, undefined);
        }
        var ch = this.str.charAt(this.pos);
        if (Tokenizer.isWordChar(ch)) {
          return new Token(TOKEN_TYPE_WORD, this.extractWord());
        } else if (ch === '{') {
          return new Token(TOKEN_TYPE_WORD, this.extractBracedWord());
        } else {
          throw new TclError("Unexpected token '" + ch + "' at pos " + this.pos + ".");
        }
      }
    }
    
    function initClient() {
      console.log('Loaded gapi');
      
      var good = true;
      var apiKey = url('#api_key');
      var clientId = url('#client_id');
      
      if (apiKey === undefined) {
        window.alert("api_key parameter must be set.");
        good = false;
      }
      if (clientId === undefined) {
        window.alert("client_id parameter must be set.");
        good = false;
      }
      if (!good) {
        return;
      }

      // 2. Initialize the JavaScript client library.
      gapi.client.init({
        'apiKey': apiKey,
        // Your API key will be automatically added to the Discovery Document URLs.
//         'discoveryDocs': ['https://people.googleapis.com/$discovery/rest'],
        // clientId and scope are optional if auth is not required.
        'clientId': clientId,
        'scope': SCOPE,
      })
        .then(
          function() {
            var needToSignIn = true;
            GoogleAuth = gapi.auth2.getAuthInstance();
            if (GoogleAuth.isSignedIn.get()) {
              var user = GoogleAuth.currentUser.get();
              var isAuthorized = user.hasGrantedScopes(SCOPE);
              if (!isAuthorized) {
                console.log("Signed in and not authorized.");
              } else {
                needToSignIn = false;
                console.log("Signed in and authorized!");
              }
            } else {
              console.log("Not signed in.");
            }
            if (needToSignIn) {
              return GoogleAuth.signIn({
                'prompt': 'consent',
              });
            }
            return Promise.resolve("doesn't matter");
          })
        .then(
          function() {
            // 3. Initialize and make the API request.
            console.log('Requesting files.list');
            return gapi.client.request({
              'path': 'https://www.googleapis.com/drive/v3/files',
              'params': {
                'spaces': 'drive' /*,appDataFolder*/,
                'q': "name contains '.shot'",
              },
            });
          },
          function(reason) {
            console.log('Error: ' + reason);
    //         console.log('Error: ' + reason.result.error.message);
          })
        .then(
          function(response) {
            // File listing
            console.log(response.result);
            
            var shotFiles = response.result.files.filter(file => file.name.endsWith('.shot'));
            console.log(shotFiles);
            
            // Now take first result and lets get its contents
            var fileId = shotFiles[0].id;
            return gapi.client.request({
              'path': 'https://www.googleapis.com/drive/v3/files/' + fileId,
              'params': {
                 'alt': 'media',
              },
            });
          },
          function(reason) {
            console.log('Error: ' + reason.result.error.message);
          })
        .then(
          function(response) {
            console.log(response);
            //$("#file_contents").html(textToHtml(response.body));
            
            var shot = shotFromShotFileContents(response.body);
            shot.renderText($("#file_contents"));
            
            var plot = document.getElementById('shot_plot');
            shot.renderPlot(plot);

          },
          function(reason) {
            console.log('Error: ' + reason);
//             console.log('Error: ' + reason.result.error.message);
          });

    }
    
    function textToHtml(text) {
      return text.replace(new RegExp('\n', 'g'), '<br>');
    }
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script type="text/javascript" src="https://apis.google.com/js/client.js?onload=gapi_loaded"></script>

</head>
<body>
  <h3>Hello World</h3>
  <div class="shot_plot" id="shot_plot"></div>
  <div class="shot_text" id="file_contents"></div>
</body>
</html>
