<!DOCTYPE html>
<html>
<head>
  <link href="https://fonts.googleapis.com/css?family=Roboto:300,900" rel="stylesheet">
  <style>
    .odd-nav {
      color: gray;
      font-size: 5vw;
      margin: 1vh .5vw;
      font-family: 'Roboto', sans-serif;
      font-weight: 900;
    }
    .even-nav {
      color: rgb(128,0,0);
      font-size: 5vw;
      margin: 1vh .5vw;
      font-family: 'Roboto', sans-serif;
      font-weight: 900;
    }
    /* Get rid of link text coloring and underlines. */
    a {
      text-decoration: none;
    }
    
    .form-text {
      font-family: 'Roboto', sans-serif;
      font-weight: 300;
    }
    div.form {
      display: table-row;
    }
    label, input[type=text] {
      display: table-cell;
      margin-bottom: 10px;
      margin-left: 10px;
    }
    #api-form-warning {
      color: red;
      font-family: 'Roboto', sans-serif;
      font-weight: 300;
      margin-top: 10px;
    }

    #shot-file-select {
      font-family: 'Roboto', sans-serif;
      font-weight: 300;
    }
    
    .listing-entry {
      font-family: 'Roboto', sans-serif;
      font-weight: 300;
    }

    .shot_plot {
      /* Force a ratio of 5:1 for all <div>
       .viewportRatio(4, 3); */
      width: 100vw;
      
      /*height: 75vw;*/ /* height:width ratio = 3/4 = .75  */
      height: 56.25vw; /* height:width ratio = 9/16 = .5625  */
      max-height: 100vh;
      /*max-width: 133.33vh;*/ /* 4/3 = 1.3333 */
      max-width: 177.78vh; /* 16/9 = 1.778 */



      margin: 0;
      resize: both;
/*       position: absolute;
      top: 0; right: 0; bottom: 0; left: 0; */
    }
    
    .shot_text {
      /* Force a ratio of 5:1 for all <div>
       .viewportRatio(4, 3); */

      margin: 0;
/*       position: absolute;
      top: 0; right: 0; bottom: 0; left: 0; */
    }
  </style>
  <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/js-url/2.5.3/url.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  
  <!-- Move this to gapi_wrapper.js-->
  <script type="text/javascript">
    "use strict";
    
    // Parse the date out of shot file filenames.
    // Assume file will CONTAIN this pattern, not exactly match.
    // A user may edit filename, but is expected to leave datetime intact.
    // Example filename: "20190202T141820.shot" or "freds_20190202T141820.shot"
    const SHOTFILE_DATETIME_PATTERN = /(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})/i;

    class DirectoryMetadata {
       constructor(fileId, name) {
         this.fileId = fileId;
         this.name = name;
       }
    }
    
    class ShotFileMetadata {
      constructor(fileId, name, parents, datetime) {
        this.fileId = fileId;
        this.name = name;
        this.parents = parents; // DirectoryMetadata[]
        this.datetime = datetime;
        this.friendlyName = null; // TODO: remove. layer breaking.
      }
    }

    // TODO: locking
    class _GapiWrapper {
      constructor() {
        this.activeApiKey = null;
        this.activeClientId = null;
        this.acquiringApiKey = null;
        this.acquiringClientId = null;
        this.whenApiKeyAndClientIdAuthed = null;
        this.whenClientAndAuthLoaded = null;
      }
      
      ensureClientAndAuthLoaded() {
        if (this.whenClientAndAuthLoaded !== null) {
          return this.whenClientAndAuthLoaded;
        }
        
        this.whenClientAndAuthLoaded = new Promise(
          resolve => gapi.load('client:auth2', resolve));
        return this.whenClientAndAuthLoaded;
      }
      
      
      ensureApiKeyAndClientIdAuthed(apiKey, clientId) {
        // TODO: refactor
        var SCOPE = 'https://www.googleapis.com/auth/drive.readonly';
//       SCOPE += ' https://www.googleapis.com/auth/drive.appdata';

        // TODO: also check that another api/client hasn't begun auth.
        if (this.activeApiKey === apiKey && this.activeClientId === clientId) {
          return Promise.resolve(true);
        }
        
        if (this.acquiringApiKey === apiKey && this.acquiringClientId === clientId && this.whenApiKeyAndClientIdAuthed !== null) {
          return this.whenApiKeyAndClientIdAuthed;
        }
        
        this.acquiringApiKey = apiKey;
        this.acquiringClientId = clientId;
        this.whenApiKeyAndClientIdAuthed =
          this.ensureClientAndAuthLoaded()
          .then(
            // Init client.
            function() {
              return gapi.client.init({
                'apiKey': apiKey,
                'clientId': clientId,
                'scope': SCOPE,
              });
            },
            function() {
              // Throw.
            }
          )
          .then(
            // Ensure signed in.
            function() {
              var needToSignIn = true;
              var GoogleAuth = gapi.auth2.getAuthInstance();
              if (GoogleAuth.isSignedIn.get()) {
                var user = GoogleAuth.currentUser.get();
                var isAuthorized = user.hasGrantedScopes(SCOPE);
                if (!isAuthorized) {
                  console.log("Signed in and not authorized.");
                } else {
                  needToSignIn = false;
                  console.log("Signed in and authorized!");
                }
              } else {
                console.log("Not signed in.");
              }
              if (needToSignIn) {
                return GoogleAuth.signIn();
              }
              return Promise.resolve(true);
            },
            function() {
              // Throw.
            }
          )
          .then(
            // Record that we are signed in.
            () => {
              // TODO: check that acquiring is same as local key and client id. If not, then do not record?
              this.activeApiKey = apiKey;
              this.activeClientId = clientId;
            },
            function() {
              // Throw
              console.log('signIn() failed apparently.');
            }
          );
        return this.whenApiKeyAndClientIdAuthed;
      }
      
      /** Use once authenticated and authorized. */
      listShotFiles(parentFilterSet = new Set()) {
        console.log('Requesting files.list');
        var q = "name contains '.shot'";
        if (parentFilterSet.size > 0) {
          q += " and (";
          var delimiter = '';
          parentFilterSet.forEach(
            parent => {
              // Overcollects to all files where any ancestor matches the filter.
              q += delimiter + `${parent} in parents`;
              delimiter = ' or ';
            });
          q += ")";
        }
        return gapi.client.request({
          'path': 'https://www.googleapis.com/drive/v3/files',
          'params': {
            'spaces': 'drive' /*,appDataFolder*/,
            'q': q,
            'fields': 'nextPageToken,files(id,name,parents)',
          },
        })
        .then(
          // Lookup parent names.
          function(response) {
            // File listing
            console.log(response);

            var shotFiles = response.result.files.filter(
              file => {
                if (!file.name.endsWith('.shot')) {
                  return false;
                }
                return parentFilterSet.size == 0 ||
                  file.parents.length == 0 ||
                  parentFilterSet.has(file.parents[file.parents.length - 1]);
              });
            console.log(shotFiles);
            
            var parents = new Set(
              shotFiles
                .flatMap(shotFile => shotFile.parents));
            var batch = gapi.client.newBatch();
            parents.forEach(
              parent => {
                batch.add(
                  gapi.client.request({
                    'path': `https://www.googleapis.com/drive/v3/files/${parent}`,
                    'params': {
                      'fields': 'id,name',
                    },
                  }),
                  {
                    id: parent,
                  });
              });

            return batch
              .then(
                function(response) {
                  console.log(response);
                  
                  var parentIdToResourceMapping = response.result;
                  
                  return shotFiles
                    .map(
                      shotFile => {
                        // Exact file datetime.
                        var datetime = null;
                        var result = SHOTFILE_DATETIME_PATTERN.exec(shotFile.name);
                        if (result === null) {
                          console.log(`Failed to find datetime of shot file ${shotFile.name} (${shotFile.fileId}).`);
                        } else {
                          datetime = new Date(result[1], result[2], result[3], result[4], result[5], result[6]);
                        }

                        // Extract parents metadata.
                        var parentIdToDirectoryMetadata = new Map();
                        Object.keys(parentIdToResourceMapping)
                          .forEach(parentId => {
                            parentIdToDirectoryMetadata.set(
                              parentId,
                              new DirectoryMetadata(
                                parentId,
                                parentIdToResourceMapping[parentId].result.name));
                          });

                        // Then create arrays of them for files
                        var parents = shotFile.parents.map(
                          parentId => parentIdToDirectoryMetadata.get(parentId));
                        return new ShotFileMetadata(shotFile.id, shotFile.name, parents, datetime);                      
                      })
                    .sort(
                      (first, second) => first.datetime < second.datetime);
                },
                function() {
                  // Throw.
                  console.log('Error: ' + reason);
                }
              );
          },
          function(reason) {
            // Throw.
            console.log('Error: ' + reason);
          }
        );
      }
      
      /** Use once authenticated and authorized. */
      getFileContents(fileId) {
        return gapi.client.request({
          'path': 'https://www.googleapis.com/drive/v3/files/' + fileId,
          'params': {
             'alt': 'media',
          },
        })
        .then(
          function(response) {
            console.log(response);
            return response.body;
          },
          function(reason) {
            // Throw
            console.log(reason.result.error.message);
          }
        );
      }
    }

    window.GapiWrapper = new _GapiWrapper();
  </script>
  
  <script type="text/javascript">
    "use strict";
    
    /* Main navigation change entrypoints:
     * 1. Initial page load -> gapi API onload mechanism -> gapi_loaded() -> onHashChange(). 
     *    For anything that needs to happen for all navigation changes, favor waiting for gapi_loaded()
     *    to be called to minimize duplication in DOMContentLoaded event. One-off operations can happen
     *    in the latter.
     * 2. After initial page load, hash location change -> onHashChange().
     *    Any important change in page state will result in a hash change with hash arguments holding
     *    the critical state.
     *    
     * All common navigation change handling starts in onHashChange().
     */
    
    var VIEW_NAMES_TO_CONTAINER_IDS = {
      api_form: 'api-form-container',
      list: 'listing-container',
      single: 'single-shot-container'
    };
    function activateViewContainer(viewNameToActivate) {
      var containerIdToActivate = VIEW_NAMES_TO_CONTAINER_IDS[viewNameToActivate];
      document.getElementById(containerIdToActivate).hidden = false;
      Object.keys(VIEW_NAMES_TO_CONTAINER_IDS)
        .filter(viewName => viewName !== viewNameToActivate)
        .forEach(viewName =>
                 document.getElementById(VIEW_NAMES_TO_CONTAINER_IDS[viewName]).hidden = true);
    }
    
    function applyHashArgIfDefined(obj, key) {
      var value = url('#' + key); 
      if (value !== undefined) {
        obj[key] = value;
      }
    }
    
    function hashToLocationString(hashArgs) {
      var newLocation = '#' + Object.entries(hashArgs)
        .map(kvPair => `${kvPair[0]}=${kvPair[1]}`)
        .join('&');
      return newLocation;
    }
    
    var PERSISTENT_HASH_ARGS = [
      'api_key',
      'client_id',
      'parent_filter_set'
    ]
    function getPersistentHashArgs() {
      var hashArgs = {};
      PERSISTENT_HASH_ARGS
        .forEach(arg => applyHashArgIfDefined(hashArgs, arg));
      return hashArgs;
    }
    
    /** Updates nav links based on "persistent" state. */
    function updateNav() {
      var persistentHashArgs = getPersistentHashArgs();
      document.getElementById('shots-nav').href =
        hashToLocationString(
          {...persistentHashArgs, view: 'list'}
        );
    }
    
    function maybeShowApiForm(apiKey, clientId) {
      // TODO: manage showing/hiding sets of controls better.
      if (apiKey === undefined || clientId === undefined) {
        activateViewContainer('api_form');
        apiFormContainer.hidden = false;
        document.getElementById('api-form-api-key').value = (apiKey === undefined) ? "" : apiKey;
        document.getElementById('api-form-client-id').value = (clientId === undefined) ? "" : clientId;
        return true;
      }
      return false;
    }
    
    /** Returns a Set of parent filters. The Set is empty if there's no parent filters. */
    function getParentFilterSet() {
      var parent_filter_set_raw = url('#parent_filter_set');
      if (parent_filter_set_raw === undefined) {
        return new Set();
      }
      var parentFilterSet = new Set(parent_filter_set_raw.split(','));
      return parentFilterSet;
    }
    
    function dateWithoutTime(date) {
      return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    }
    
    function redirectLocation(apiKey, clientId, redirect) {
      var parentFilterSet = getParentFilterSet();
      GapiWrapper.ensureApiKeyAndClientIdAuthed(apiKey, clientId)
        .then(
          function() {
            console.log('listShotFiles??');
            return GapiWrapper.listShotFiles(parentFilterSet);
          },
          function() {
            // Throw.
            console.log('Auth failed apparently.');
          }
        )
        .then(
          function(shotFileMetadatas) {
            // Convert redirects from indirect reference to absolute shot index.
            var realIndex = undefined;
            switch (redirect) {
              // TODO: maybe develop into day and day index. or month and month index
              case 'yesterday':
                // Go backwards through listing until you find anything before today.
                var now = new Date(Date.now());
                var todayThreshold = dateWithoutTime(now).getTime();
                for (let i = shotFileMetadatas.length - 1; i != 0; --i) {
                  var metadata = shotFileMetadatas[i];
                  if (metadata.datetime.getTime() < todayThreshold) {
                    // Last shot that didn't happen today.
                    realIndex = i;
                    break;
                  }
                }
                // Let realIndex = undefined fall through.
                break;
              case 'absolute_index': // Lack of better name
                // 0: first
                // n-1: last
                // inf: last
                // -1: last
                // -n: first
                // -inf: first
                var n = shotFileMetadatas.length;
                var absoluteIndex = Number(url('#absolute_index')); // TODO: sanitize to integer
                if (absoluteIndex < 0) {
                  realIndex = n + absoluteIndex;
                  if (realIndex < 0) {
                    realIndex = 0;
                  }
                } else if (absoluteIndex >= n) {
                  realIndex = n-1;
                }
                if (realIndex < 0) {
                  // There's zero shots for some reason.
                  realIndex = undefined;
                }
                break;
            }
            var hashArgs = getPersistentHashArgs();
            if (realIndex === undefined) {
              // No shots. Let's just do a listing instead.
              hashArgs['view'] = 'list';
            } else {
              // Translate to fileId.
              var fileId = shotFileMetadatas[realIndex].fileId;
              hashArgs['view'] = 'single';
              hashArgs['shot_file_id'] = fileId;
            }
            replaceLocationWithHash(hashArgs);
            // Queue hash change.
            Promise.resolve(true).then(() => onHashChange());
          });
    }
    
    /* missing api_key or client_id beats everything else
     * redirect beats view
     */
    
    // The main feeder for location changes.
    function onHashChange() {
      console.log(`hash=${window.location.hash}`);
      
      updateNav();

      // Shift in all parameters now, incase there is another hash change.
      var apiKey = url('#api_key');
      var clientId = url('#client_id');
      var view = url('#view');
      
      // Default view mode.
      if (view === undefined) {
        view = 'list';
      }
      
      if (maybeShowApiForm(apiKey, clientId)) {
        return;
      }
      
      // TODO: further sanitize view
      activateViewContainer(view);
      
      // Redirects
      var redirect = url('#redirect');
      if (redirect !== undefined) {
        // TODO: get list of files (filtered by parent_set) then index by redirect
        // TDOO: consider caching implications. always refresh, or reuse in-page cache.
        redirectLocation(apiKey, clientId, redirect);
        return;
      }

      // Async acquiring authorization.
      var whenAuthed = GapiWrapper.ensureApiKeyAndClientIdAuthed(apiKey, clientId);
      
      switch (view) {
        case 'list':
          // Can arrange DOM immediately.
          var shotFileSelect = document.getElementById('shot-file-select');
          // Reset state of select.
          while (shotFileSelect.firstChild) {
            shotFileSelect.removeChild(shotFileSelect.firstChild);
          }
          var defaultOpt = document.createElement('option');
          defaultOpt.value = '';
          defaultOpt.innerHTML = '-- Shot Files --';
          shotFileSelect.appendChild(defaultOpt);
          // Reset state of list container
          var listingContainer = document.getElementById('listing-container');
          while (listingContainer.firstChild) {
            listingContainer.removeChild(listingContainer.firstChild);
          }
          
          // Async.
          whenAuthed.then(
            function() {
              console.log('listShotFiles??');
              return GapiWrapper.listShotFiles();
            },
            function() {
              // Throw.
              console.log('Auth failed apparently.');
            }
          )
          .then(
            function(shotFileMetadatas) {
              // File listing
              console.log(shotFileMetadatas);
              var shotFileIdsToListingLabels = mapShotFileIdsToListingLabels(shotFileMetadatas);
              shotFileMetadatas.forEach(
                (metadata) => {
                  var opt = document.createElement('option');
                  opt.value = metadata.fileId;
                  // For now, this will do.
                  var listingLabel = shotFileIdsToListingLabels.get(metadata.fileId);
                  opt.innerHTML = listingLabel.timeLabel + listingLabel.fileSystemLabel;
                  shotFileSelect.appendChild(opt);
                  
                  // Append to listing container
                  var entry = document.createElement('div');
                  entry.innerHTML = `<h3>${listingLabel.timeLabel}</h3><br><h4>${listingLabel.fileSystemLabel}</h4>`;
                  entry.className = 'listing-entry';
                  listingContainer.appendChild(entry);
                });
            },
            function() {
              // Throw
              console.log('listShotFiles failed apparently.');
            }
          );
          break;

        case 'single':
          var shotFileId = url('#shot_file_id');
          
          // Can arrange DOM immediately.
          if (shotFileId === undefined) {
            // Throw.
            console.log('No shot file to show.');
            break;
          }
          
          // Async
          whenAuthed.then(
            function() {
              return GapiWrapper.getFileContents(shotFileId);
            },
            function() {
              // Throw.
              console.log('auth failed');
            }
          )
          .then(
            function(fileContents) {
              var shot = shotFromShotFileContents(fileContents);
              shot.renderText(document.getElementById('file_contents'));
              var plot = document.getElementById('shot_plot');
              shot.renderPlot(plot);
            },
            function() {
              // Throw
              console.log('file retrieval failed');
            }
          );
          break;
          
        default:
          // Throw.
      }
    }
    window.addEventListener('hashchange', onHashChange, false);
    
//     var GoogleAuth;
//     var SCOPE = 'https://www.googleapis.com/auth/drive.readonly';
//       SCOPE += ' https://www.googleapis.com/auth/drive.appdata';
    
    function gapi_loaded() {
      // Call for initial page load.
      onHashChange();

//       console.log('Loading gapi');
//       gapi.load('client:auth2', initClient);
    }
      
    /** Returns Map of locale date (clock time) to ShotFileMetadata (preserves order). */
    function groupShotsByDate(metadatas) {
      return metadatas.reduce( // Groupby date.
        (groupings, metadata) => {
          // valueOf() for correct key equality mechanics.
          var dateEpoch = dateWithoutTime(metadata.datetime).valueOf();
          if (!groupings.has(dateEpoch)) {
            groupings.set(dateEpoch, []);
          }
          grouping = groupings.get(dateEpoch).push(metadata);
        },
        new Map());
    }
      
    // TODO: breakdown:
    //       make struct with information important to display (e.g. # shot of day), but render UI later with a renderer class.
    /**
     * timeLabel: label indicating time-oriented information about shot.
     * fileSystemLabel: label indicating filesystem-oriented information about shot. 
     */
    class ShotListingLabel {
      constructor(timeLabel, fileSystemLabel) {
        this.timeLabel = timeLabel;
        this.fileSystemLabel = fileSystemLabel;
      }
    }
      
    /** shotFileMetadatas must be ordered in ascending datetime. */
    function mapShotFileIdsToListingLabels(shotFileMetadatas) {
      var mapping = new Map();
      groupShotsByDate(shotFileMetadatas)
        .forEach((grouping, epochTime) => {
          var date = new Date(epochTime);
          var timeLabelPrefix = `${date.toDateString()}`;
          for (let i of grouping.keys()) {
            var metadata = grouping[i];
            // e.g. Wed Jul 28 1993 #3 (23:15:30 GMT+0200 (CEST))
            var timeLabel = timeLabelPrefix + ` #${i+1} (${metadata.datetime.toTimeString()})`;
            // e.g. path/to/shotfile.shot
            var fileSystemLabel =
                metadata.parents
                  .map(parent => parent.name)
                  .join('/')
                + `/${metadata.name}`;
            mapping.set(metadata.fileId, new ShotListingLabel(timeLabel, fileSystemLabel));
          }
        });
      return mapping;
    }
    
    function replaceLocationWithHash(params) {
      window.history.replaceState({}, '', hashToLocationString(params));
    }
    // Setup other static stuff.
    function gotoHash(params) {
      window.location = hashToLocationString(params);
    }
    function gotoSingleShot(fileId) {
      var api_key = url('#api_key');
      var client_id = url('#client_id');
      gotoHash({
        api_key: api_key,
        client_id: client_id,
        view: 'single',
        shot_file_id: fileId,
      });
    }
    
    document.addEventListener('DOMContentLoaded',function() {
      document.querySelector('select[id="shot-file-select"]').onchange = shotFileSelectChanged;
      
      // Setup api form handlers.
      document.getElementById('api-form-set').onclick = function() {
        var api_key = document.getElementById('api-form-api-key').value;
        var client_id = document.getElementById('api-form-client-id').value;
        console.log(`api_key ${api_key} client_id ${client_id}`);
        var warning = document.getElementById('api-form-warning');
        if (api_key === '' || client_id === '') {
          warning.hidden = false;
        } else {
          warning.hidden = true;
          var hashArgs = url('#');
          hashArgs['api_key'] = api_key;
          hashArgs['client_id'] = client_id;
          gotoHash(hashArgs);
        }
        return false;
      };

    }, false);

    function shotFileSelectChanged(event) {
      if (event.target.value === '') {
        return;
      }
      var fileId = event.target.value;
      gotoSingleShot(fileId);
    }



    
    /* Based upon:
     *  -http://ryanogles.by/an-exploration-of-javascript-builders/
     *  -https://medium.com/@axelhadfeg/builder-pattern-using-javascript-and-es6-ec1539182e24
     */
    class BaseBuilder {
      init() {  
        Object.keys(this).forEach((key) => {
          const setterName = `set${key.substring(0,1).toUpperCase()}${key.substring(1)}`;
          this[setterName] = (value) => {
            this[key] = value;
            return this;
          };
        });
      }

      build() {
        const fields = Object.keys(this).filter((key) => (
          typeof this[key] !== 'function'
        ));
                
        var properties =  fields.reduce((returnValue, key) => {
          return {
            ...returnValue,
            [key]: {
              value: this[key],
              writable: false
            }
          };
        }, {});
        
        var outputObject = {};
        Object.defineProperties(outputObject, properties);
        
        this.addMemberFunctions(outputObject);
        
        return outputObject;
        
//         return keysNoWithers.reduce((returnValue, key) => {
//           return {
//             ...returnValue,
//             [key]: this[key]
//           };
//         }, {});
      }
    }

    class ShotSyntaxError extends Error {
      constructor(...params) {
        super(...params);
        
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ShotSyntaxError);
        }
      }
    }
    class ShotBuilder extends BaseBuilder {
      constructor() {
        super();
        
        this.timestamp = new Date(0);
        this.elapsed = [];
        this.pressure = [];
        this.flow = [];
        this.weight = [];
        this.flowWeight = [];
        this.temperatureBasket = [];
        this.temperatureMix = [];
        this.temperatureTarget = [];
        this.author = "";

        super.init();
      }
      addMemberFunctions(obj) {
        obj.renderText = function(div) {
          var BR = "<br>";
          var html = 
            "timestamp: " + this.timestamp.toString() + BR
            + "elapsed: " + this.elapsed + BR
            + "pressure: " + this.pressure + BR
            + "flow: " + this.flow + BR
            + "weight: " + this.weight + BR
            + "flowWeight: " + this.flowWeight + BR
            + "temperatureBasket: " + this.temperatureBasket + BR
            + "temperatureMix: " + this.temperatureMix + BR
            + "temperatureTarget" + this.temperatureTarget + BR
            + "author: " + this.author + BR;
          div.innerHTML = html;
        }
        // Move this stuff to polymorphic renderers.
        
        obj.renderPlot = function(plot) {
//           var plot = document.getElementById('shot_plot');
          var pressure = {
            x: this.elapsed,
            y: this.pressure,
            mode: 'lines',
            name: 'Pressure',
            line: {
              color: 'green'
            }
          };
          var flow = {
            x: this.elapsed,
            y: this.flow,
            mode: 'lines',
            name: 'Flow',
            line: {
              color: 'blue'
            },
            yaxis: 'y2'
          };
          var temperatureBasket = {
            x: this.elapsed,
            y: this.temperatureBasket,
            mode: 'lines',
            name: 'Basket Temperature',
            line: {
              color: 'red'
            },
            yaxis: 'y3'
          };
          
          // TODO: align domain such that temperature target is centered.
          var center =
              this.temperatureTarget.reduce(
                (accumulator, currentValue) => accumulator + currentValue)
              / this.temperatureTarget.length;
          var maxDifference = [...Array(this.elapsed.length).keys()]
              .map(
                (index) => Math.max(Math.abs(this.temperatureTarget[index] - center), Math.abs(this.temperatureBasket[index] - center)))
              .reduce((accumulator, currentValue) => Math.max(accumulator, currentValue), 0);
          var temperatureRange = [center - maxDifference, center + maxDifference];
          var temperatureTarget = {
            x: this.elapsed,
            y: this.temperatureTarget,
            mode: 'lines',
            name: 'Target Basket Temperature',
            line: {
              color: 'red',
              dash: 'dash'
            },
            yaxis: 'y3'
          };
            
          var data = [pressure, flow, temperatureBasket, temperatureTarget];
          var layout = {
            title: `Shot @ ${this.timestamp}`,
//             showlegend: false,
            xaxis: {
              title: 'Elapsed (s)',
              domain: [0, 0.9],
            },
            yaxis: {
              title: 'Pressure (bar)',
              titlefont: {color: 'green'},
              tickfont: {color: 'green'},
              side: 'left'
            },
            yaxis2: {
              title: 'Flow (mL/s)',
              titlefont: {color: 'blue'},
              tickfont: {color: 'blue'},
              anchor: 'x',
              overlaying: 'y',
              side: 'right'
            },
            yaxis3: {
              title: 'Basket Temperature (C)',
              titlefont: {color: 'red'},
              tickfont: {color: 'red'},
              anchor: 'free',
              overlaying: 'y',
              side: 'right',
              position: 1,
              autorange: false,
              range: temperatureRange
            },
          };
          Plotly.plot(plot, data, layout);
//           Plotly.plot(plot, [{
//           x: [1, 2, 3, 4, 5],
//           y: [1, 2, 4, 8, 16] }], {
//           margin: { t: 0 } } );
        }
      }
    }
    function tclListToNumberArray(tclList) {
      return tclList.split(/\s+/).map(numStr => Number(numStr));
    }
    function shotFromShotFileContents(contents) {
      var S_TO_MS = 1000;
      var attrs = tclArrayDeserializer(contents);
      if (!attrs.has('settings')) {
        throw new ShotSyntaxError("settings key not present.");
      }
      var settings = tclArrayDeserializer(attrs.get('settings'));
      if (!attrs.has('machine')) {
        throw new ShotSyntaxError("machine key not present.");
      }
      var machine = tclArrayDeserializer(attrs.get('machine'));
      
      var espressoElapsed = tclListToNumberArray(attrs.get('espresso_elapsed'));
      var espressoPressure = tclListToNumberArray(attrs.get('espresso_pressure'));
      var espressoWeight = tclListToNumberArray(attrs.get('espresso_weight'));
      var espressoFlow = tclListToNumberArray(attrs.get('espresso_flow'));
      var espressoFlowWeight = tclListToNumberArray(attrs.get('espresso_flow_weight'));
      var espressoTemperatureBasket = tclListToNumberArray(attrs.get('espresso_temperature_basket'));
      var espressoTemperatureMix = tclListToNumberArray(attrs.get('espresso_temperature_mix'));
      
      console.log("espresso_elapsed: " + attrs.get('espresso_elapsed'));
      console.log("espressoElapsed: " + espressoElapsed);
      var numPoints = espressoElapsed.length;
      if (![espressoPressure, espressoWeight, espressoFlow, espressoFlowWeight, espressoTemperatureBasket, espressoTemperatureMix]
          .every(sequence => sequence.length == numPoints)) {
        throw ShotSyntaxError("Number of data points do not match across all dimensions.");
      }

      var builder = new ShotBuilder();
      return builder
        .setTimestamp(
          new Date(Number(attrs.get('clock') * S_TO_MS)))
        .setElapsed(espressoElapsed)
        .setPressure(espressoPressure)
        .setWeight(espressoWeight)
        .setFlow(espressoFlow)
        .setFlowWeight(espressoFlowWeight)
        .setTemperatureBasket(espressoTemperatureBasket)
        .setTemperatureMix(espressoTemperatureMix)
        .setTemperatureTarget(Array(numPoints).fill(Number(settings.get('espresso_temperature'))))
        .setAuthor(settings.get('author'))
        .build();
    }

    
    class TclError extends Error {
      constructor(...params) {
        super(...params);
        
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, TclError);
        }
      }
    }
    var TOKEN_TYPE_EOF = 1;
    var TOKEN_TYPE_WORD = 2;
    class Token {
      constructor(tokenType, value) {
        this.tokenType = tokenType;
        this.value = value;
      }
    }
    /** 
     * Processes similar to the following Tcl, where retName is a variable
     * representing the returned value of the function:
     *
     *   upvar 1 $retName arrRef
     *   array set arrRef $arrayString
     *
     * Respects rules 3 and 6 of Tcl. See https://www.tcl.tk/man/tcl/TclCmd/Tcl.htm.
     */
    function tclArrayDeserializer(arrayString) {
      // Looks for zero or more pairs of words, where a word is either
      // 1. a sequence of 1 or more non-whitespace characters, or
      // 2. a sequence of characters within a left brace '{' and its matched right brace '}', respecting nested braces.
      // A pair of words is separated by at least one non-newline whitespace characters,
      // and pairs are separated by at least one newline.
      // TODO: implement newline-related restrictions.
      
      // tokens:  (\s+), (\n), ([a-zA-Z0-9_]+), ({), (})
      var tokenizer = new Tokenizer(arrayString);
      var tclArray = new Map();
      while (1) {
        var token = tokenizer.nextToken();
        if (token.tokenType == TOKEN_TYPE_EOF) {
          break;
        }
        var key = token.value;
        token = tokenizer.nextToken();
        if (token.tokenType == TOKEN_TYPE_EOF) {
          throw new TclError("Serialized Tcl arrays should have an even number of elements.");
        }
        tclArray.set(key, token.value);
      }
      return tclArray;
    }
    class Tokenizer {
      constructor(str) {
        this.str = str;
        this.pos = 0;
      }
      static isWhitespace(ch) {
        return /\s/.test(ch);
      }
      static isWordChar(ch) {
        return /[a-zA-Z0-9_#:\.+-]/.test(ch);
      }
      eatWhitespace() {
        while (this.pos < this.str.length && Tokenizer.isWhitespace(this.str.charAt(this.pos))) {
          ++this.pos;
        }
      }
      extractWord() {
        var origin = this.pos;
         while (this.pos < this.str.length && Tokenizer.isWordChar(this.str.charAt(this.pos))) {
           ++this.pos;
         }
        return this.str.substring(origin, this.pos);
      }
      extractBracedWord() {
        var origin = this.pos;
        var depth = 0;
        do {
          var ch = this.str.charAt(this.pos);
          if (ch === '{') {
            ++depth;
          } else if (ch === '}') {
            --depth;
          }
          ++this.pos;
        } while (this.pos < this.str.length && depth != 0);
        if (depth != 0) {
          throw new TclError("Unmatched curly braces.");
        }
        return this.str.substring(
          origin+1, // Skip the '{'.
          this.pos-2); // End before the '}'.
      }
      nextToken() {
        this.eatWhitespace();
        
        if (this.pos >= this.str.length) {
          return new Token(TOKEN_TYPE_EOF, undefined);
        }
        var ch = this.str.charAt(this.pos);
        if (Tokenizer.isWordChar(ch)) {
          return new Token(TOKEN_TYPE_WORD, this.extractWord());
        } else if (ch === '{') {
          return new Token(TOKEN_TYPE_WORD, this.extractBracedWord());
        } else {
          throw new TclError("Unexpected token '" + ch + "' at pos " + this.pos + ".");
        }
      }
    }
    
    
    
//     function initClient() {
//       console.log('Loaded gapi');
      
//       var good = true;
//       var apiKey = url('#api_key');
//       var clientId = url('#client_id');
      
//       if (apiKey === undefined) {
//         window.alert("api_key parameter must be set.");
//         good = false;
//       }
//       if (clientId === undefined) {
//         window.alert("client_id parameter must be set.");
//         good = false;
//       }
//       if (!good) {
//         return;
//       }

//       // 2. Initialize the JavaScript client library.
//       gapi.client.init({
//         'apiKey': apiKey,
//         // Your API key will be automatically added to the Discovery Document URLs.
// //         'discoveryDocs': ['https://people.googleapis.com/$discovery/rest'],
//         // clientId and scope are optional if auth is not required.
//         'clientId': clientId,
//         'scope': SCOPE,
//       })
//         .then(
//           function() {
//             var needToSignIn = true;
//             GoogleAuth = gapi.auth2.getAuthInstance();
//             if (GoogleAuth.isSignedIn.get()) {
//               var user = GoogleAuth.currentUser.get();
//               var isAuthorized = user.hasGrantedScopes(SCOPE);
//               if (!isAuthorized) {
//                 console.log("Signed in and not authorized.");
//               } else {
//                 needToSignIn = false;
//                 console.log("Signed in and authorized!");
//               }
//             } else {
//               console.log("Not signed in.");
//             }
//             if (needToSignIn) {
//               return GoogleAuth.signIn({
// //                 'prompt': 'consent',
//               });
//             }
//             return Promise.resolve("doesn't matter");
//           })
//         .then(
//           function() {
//             // 3. Initialize and make the API request.
//             console.log('Requesting files.list');
//             return gapi.client.request({
//               'path': 'https://www.googleapis.com/drive/v3/files',
//               'params': {
//                 'spaces': 'drive' /*,appDataFolder*/,
//                 'q': "name contains '.shot'",
//               },
//             });
//           },
//           function(reason) {
//             console.log('Error: ' + reason);
//     //         console.log('Error: ' + reason.result.error.message);
//           })
//         .then(
//           function(response) {
//             // File listing
//             console.log(response.result);
            
//             var shotFiles = response.result.files.filter(file => file.name.endsWith('.shot'));
//             console.log(shotFiles);
            
//             // Now take first result and lets get its contents
//             var fileId = shotFiles[0].id;
//             return gapi.client.request({
//               'path': 'https://www.googleapis.com/drive/v3/files/' + fileId,
//               'params': {
//                  'alt': 'media',
//               },
//             });
//           },
//           function(reason) {
//             console.log('Error: ' + reason.result.error.message);
//           })
//         .then(
//           function(response) {
//             console.log(response);
//             //$("#file_contents").html(textToHtml(response.body));
            
//             var shot = shotFromShotFileContents(response.body);
//             shot.renderText($("#file_contents"));
            
//             var plot = document.getElementById('shot_plot');
//             shot.renderPlot(plot);

//           },
//           function(reason) {
//             console.log('Error: ' + reason);
// //             console.log('Error: ' + reason.result.error.message);
//           });

//     }
    
    function textToHtml(text) {
      return text.replace(new RegExp('\n', 'g'), '<br>');
    }
  </script>

  <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
  <script type="text/javascript" src="https://apis.google.com/js/client.js?onload=gapi_loaded"></script>

</head>
<body>
  <a id="shots-nav" href=""><span class="odd-nav">shots</span></a>
  <span class="even-nav">last</span>
  <span class="odd-nav">yesterday</span>
  <span class="even-nav">-10</span>
  <span class="odd-nav">-50</span>
  <span class="even-nav">-100</span>
  <span class="odd-nav">first</span>
  <br>

  <div id="api-form-container" hidden>
    <form method="get">
      <div class="form">
        <label class="form-text" for="api-form-api-key">api key</label>
        <input id="api-form-api-key" type="text" name="api_key">
      </div>
      <div class="form">
        <label class="form-text" for="api-form-client-id">client id</label>
        <input id="api-form-client-id" type="text" name="client_id">
      </div>
      <input class="form-text" id="api-form-set" type="submit" value="Set">
      <div id="api-form-warning" hidden>api key and client id must be populated to set.</div>
    </form>
  </div>
  <!-- <button onclick="appendToHash()">Append to hash</button> -->
  <select id="shot-file-select">
  </select>
  
  <div id="listing-container" hidden>
  </div>

  <div id="single-shot-container" hidden>
    <div class="shot_plot" id="shot_plot"></div>
    <div class="shot_text" id="file_contents"></div>
  </div>
</body>
</html>
